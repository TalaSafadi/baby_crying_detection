import os
import pandas as pd
import librosa
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.tree import DecisionTreeClassifier
from sklearn.metrics import accuracy_score
from sklearn.utils import resample
import joblib


# Function to extract features from audio file
def extract_features(file_path):
    y, sr = librosa.load(file_path)
    mfcc = librosa.feature.mfcc(y=y, sr=sr, n_mfcc=13)
    zero_crossing_rate = librosa.feature.zero_crossing_rate(y)
    spectral_centroid = librosa.feature.spectral_centroid(y=y, sr=sr)

    return {
        'mfcc_mean': mfcc.mean(),
        'zero_crossing_rate_mean': zero_crossing_rate.mean(),
        'spectral_centroid_mean': spectral_centroid.mean(),
    }


# Function to prepare the dataset
def prepare_dataset(audio_dir):
    data = []
    labels = []

    for file_name in os.listdir(audio_dir):
        file_path = os.path.join(audio_dir, file_name)
        features = extract_features(file_path)
        data.append(features)

        # Assign label based on file name
        if "crying" in file_name:
            labels.append("crying")
        else:
            labels.append("non-crying")

    df = pd.DataFrame(data)
    df['label'] = labels

    return df


# Function to train the model
def train_model(df):
    X = df.drop('label', axis=1)
    y = df['label']

    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

    clf = DecisionTreeClassifier()
    clf.fit(X_train, y_train)

    y_pred = clf.predict(X_test)
    accuracy = accuracy_score(y_test, y_pred)
    print("Accuracy:", accuracy)

    return clf, accuracy


# Function to balance the dataset
def balance_dataset(df):
    crying_samples = df[df['label'] == 'crying']
    silence_samples = df[df['label'] == 'non-crying']

    majority_class = 'crying' if len(crying_samples) > len(silence_samples) else 'non-crying'
    if majority_class == 'crying':
        minority_samples = silence_samples
        majority_samples = crying_samples
    else:
        minority_samples = crying_samples
        majority_samples = silence_samples

    resampled_minority = resample(minority_samples,
                                  replace=True,
                                  n_samples=len(majority_samples),
                                  random_state=42)

    resampled_df = pd.concat([majority_samples, resampled_minority])
    resampled_df = resampled_df.sample(frac=1, random_state=42).reset_index(drop=True)

    return resampled_df


# Function to extract features for a single audio file
def extract_features_single(file_path):
    y, sr = librosa.load(file_path)
    mfcc = librosa.feature.mfcc(y=y, sr=sr, n_mfcc=13)
    zero_crossing_rate = librosa.feature.zero_crossing_rate(y)
    spectral_centroid = librosa.feature.spectral_centroid(y=y, sr=sr)

    return np.array([mfcc.mean(), zero_crossing_rate.mean(), spectral_centroid.mean()])


# Save the trained model
def save_model(model, path='audio_classification_model.pkl'):
    joblib.dump(model, path)


# Load a saved model
def load_model(path='audio_classification_model.pkl'):
    return joblib.load(path)
